<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Big Data Formats — Interactive Guide</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #f8f7f4;
    --card: #ffffff;
    --muted: #6b615b;
    --text: #4a4a4a;
    --accent: #8c7b72;
    --accent-strong: #6f5f57;
    --accent-light: #d3c1b9;
    --accent2: #8c7b72;
    --border: #eaddd7;
    --border-strong: #c8b4ab;
    --good: #2f855a;
    --warn: #b7791f;
    --bad: #c53030;
  }
  * { box-sizing: border-box; }
  body {
    margin: 0;
    font-family: 'Inter', sans-serif;
    background: var(--bg);
    color: var(--text);
  }
  a { color: var(--accent); text-decoration: none; }
  a:hover { color: var(--accent-strong); }
  .container {
    width: min(1200px, 92vw);
    margin: 0 auto;
  }
  .site-header {
    position: sticky;
    top: 0;
    z-index: 50;
    background: #ece5e1;
    border-bottom: 1px solid var(--border);
    box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05), 0 2px 4px -1px rgba(0,0,0,0.03);
  }
  .nav-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 16px;
    padding: 14px 0;
    flex-wrap: wrap;
  }
  .home-button {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    color: var(--accent);
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 999px;
    padding: 8px 18px;
    transition: all 0.2s ease;
  }
  .home-button:hover {
    border-color: var(--accent);
    background: #f1e6e1;
  }
  .nav-actions {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
  }
  .nav-actions a {
    display: inline-flex;
    align-items: center;
    font-weight: 600;
    color: #63534d;
    font-size: 14px;
    padding: 8px 16px;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: rgba(255,255,255,0.7);
    transition: all 0.2s ease;
  }
  .nav-actions a:hover {
    border-color: var(--accent);
    box-shadow: 0 12px 22px rgba(99,83,77,0.18);
    color: var(--accent);
    background: rgba(255,255,255,0.95);
  }
  .page {
    padding: 48px 0 72px;
    display: flex;
    flex-direction: column;
    gap: 32px;
  }
  h1, h2, h3 { margin: 0; }
  h1 { font-size: 2.5rem; color: #63534d; }
  h2 { font-size: 1.75rem; color: #63534d; }
  h3 { font-size: 1.25rem; color: #6f5f57; }
  p { color: var(--muted); line-height: 1.7; margin: 0; }
  .grid {
    display: grid;
    gap: 16px;
  }
  .grid.cols-2 { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
  .grid.cols-3 { grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); }
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 20px;
    padding: 28px;
    box-shadow: 0 15px 30px rgba(99,83,77,0.08);
    transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
  }
  .card:hover {
    transform: translateY(-2px);
    box-shadow: 0 22px 44px rgba(99,83,77,0.12);
  }
  .card.highlight {
    border-color: var(--accent);
    box-shadow: 0 22px 44px rgba(99,83,77,0.18);
  }
  .hero-card {
    background: linear-gradient(135deg, rgba(236,229,225,0.6), rgba(255,255,255,0.95));
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .hero-card__heading {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .lead {
    font-size: 1.1rem;
    color: var(--text);
  }
  .pill {
    color: #63534d;
    background: #ece5e1;
    border: 1px solid var(--border);
    padding: 6px 12px;
    border-radius: 999px;
    font-weight: 600;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .filters-panel {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  .filters-panel__header {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .tag {
    display: inline-flex;
    align-items: center;
    font-size: 12px;
    padding: 4px 10px;
    margin: 2px 6px 2px 0;
    border-radius: 999px;
    border: 1px solid var(--border);
    background: #f5ede9;
    color: #63534d;
    font-weight: 500;
  }
  .tag.good {
    border-color: rgba(72,187,120,0.4);
    background: rgba(72,187,120,0.12);
    color: #276749;
  }
  .tag.warn {
    border-color: rgba(236,201,75,0.55);
    background: rgba(236,201,75,0.18);
    color: #8b5e11;
  }
  .tag.bad {
    border-color: rgba(229,62,62,0.45);
    background: rgba(229,62,62,0.16);
    color: #822727;
  }
  details {
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 14px 18px;
    margin: 12px 0;
    background: #f4ede9;
    transition: border-color 0.2s ease, background 0.2s ease;
  }
  details[open] {
    background: #efe2db;
    border-color: var(--accent);
  }
  summary {
    cursor: pointer;
    font-weight: 600;
    color: var(--accent);
  }
  summary:hover { text-decoration: underline; }
  code, pre {
    background: #2f2a26;
    border: 1px solid #4a4039;
    border-radius: 12px;
    color: #f5ede5;
  }
  code { padding: 2px 8px; display: inline-block; }
  pre { padding: 12px; overflow: auto; }
  .row { display:flex; align-items:center; gap:12px; flex-wrap: wrap; }
  .toolbar {
    display:flex;
    gap:12px;
    flex-wrap: wrap;
    align-items: center;
    padding: 16px;
    border:1px solid var(--border);
    border-radius: 16px;
    background: rgba(236,229,225,0.55);
  }
  input[type="search"], select, button {
    background: var(--card);
    color: var(--text);
    border:1px solid var(--border);
    padding:10px 12px;
    border-radius: 12px;
    outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  input[type="search"]:focus, select:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(140,123,114,0.25);
  }
  .toolbar button {
    cursor: pointer;
    background: var(--accent);
    color: #ffffff;
    border-color: var(--accent);
    font-weight: 600;
  }
  .toolbar button:hover {
    background: var(--accent-strong);
    border-color: var(--accent-strong);
  }
  .copy-btn {
    float: right;
    margin-left: 8px;
    padding: 4px 10px;
    font-size: 12px;
    background: #f8f1ec;
    color: #63534d;
    border:1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
  }
  .copy-btn:hover {
    background: #ede0d8;
    color: var(--accent-strong);
    transform: translateY(-1px);
  }
  table { width: 100%; border-collapse: collapse; }
  th, td {
    border-bottom: 1px solid var(--border);
    padding: 12px 10px;
    text-align: left;
    vertical-align: top;
  }
  th {
    position: sticky;
    top: 0;
    background: rgba(248,244,240,0.95);
    backdrop-filter: blur(4px);
    z-index:1;
    cursor: pointer;
    transition: color 0.2s ease;
    font-weight: 600;
    color: #574840;
  }
  th:hover { color: var(--accent); }
  tbody tr:hover { background: rgba(236,229,225,0.45); }
  .small { font-size: 12px; color:#8c7b72; }
  .section {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  .kbd { border:1px solid #d3c1b9; background:#f5ede9; padding:2px 6px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color:#6f5f57; }
  footer { color:#8c7b72; font-size: 12px; margin-top: 40px; text-align:center; }
  .highlight-row { background-color: rgba(140,123,114,0.18); }
  .concept-card {
    background: linear-gradient(135deg, rgba(140,123,114,0.08), rgba(234,221,215,0.6));
    border: 1px solid rgba(140,123,114,0.25);
    margin-bottom: 16px;
  }
  .concept-card h3 { margin-top: 0; color: #6f5f57; }
  .concept-card p { margin-bottom: 0; }
  .flow-diagram-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px;
    padding: 20px;
    background: linear-gradient(135deg, rgba(236,229,225,0.7), rgba(255,255,255,0.8));
    border-radius: 16px;
    border: 1px solid rgba(140,123,114,0.3);
  }
  .flow-step {
    text-align: center;
    color: var(--accent);
    font-weight: 600;
  }
  .flow-arrow {
    font-size: 2rem;
    color: var(--accent2);
    transform: rotate(90deg);
  }
  .report-callout {
    margin-top: 12px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 16px;
    padding: 18px 20px;
    border-radius: 16px;
    background: linear-gradient(135deg, rgba(140,123,114,0.18), rgba(217,198,189,0.25));
    border: 1px solid rgba(140,123,114,0.35);
  }
  .report-callout h3 {
    margin: 0;
    color: #56443d;
  }
  .report-callout p {
    margin: 4px 0 0;
    color: var(--muted);
  }
  .cta-button {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 16px;
    border-radius: 999px;
    background: var(--accent);
    color: #ffffff;
    font-weight: 600;
    text-decoration: none;
    transition: background 0.2s ease, box-shadow 0.2s ease;
  }
  .cta-button:hover {
    background: var(--accent-strong);
    box-shadow: 0 16px 28px rgba(111,95,87,0.25);
  }
  .format-browser {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  .format-tabs {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }
  .format-tab {
    border: 1px solid var(--border);
    background: #f5ede9;
    color: #63534d;
    padding: 10px 18px;
    border-radius: 999px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
  }
  .format-tab:hover {
    border-color: var(--accent);
    color: var(--accent);
    box-shadow: 0 8px 18px rgba(99,83,77,0.14);
  }
  .format-tab.active {
    background: var(--accent);
    color: #ffffff;
    border-color: var(--accent);
    box-shadow: 0 12px 24px rgba(111,95,87,0.22);
  }
  .format-panel {
    border: 1px solid var(--border);
    border-radius: 18px;
    background: linear-gradient(135deg, rgba(248,244,240,0.65), rgba(255,255,255,0.9));
    padding: 24px;
    min-height: 220px;
  }
  .format-card {
    display: flex;
    flex-direction: column;
    gap: 16px;
    background: #ffffff;
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px;
    box-shadow: 0 15px 30px rgba(99,83,77,0.08);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }
  .format-card .row {
    margin-bottom: 4px;
  }
  .format-card.highlight {
    border-color: var(--accent);
    box-shadow: 0 22px 44px rgba(99,83,77,0.16);
  }
  .format-card__section {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  .format-card__section h4 {
    margin: 0;
    color: #6f5f57;
    font-size: 1.05rem;
  }
  .format-empty {
    color: var(--muted);
    font-style: italic;
  }
  @media (min-width: 640px) {
    .hero-card__heading {
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
    }
    .flow-arrow {
      transform: none;
    }
    .flow-diagram-container {
      flex-wrap: nowrap;
    }
  }
  @media (max-width: 640px) {
    .nav-actions {
      width: 100%;
    }
    .nav-actions a {
      flex: 1 1 auto;
      justify-content: center;
    }
  }
</style>
</head>
<body>
  <header class="site-header">
    <nav class="container nav-bar">
      <a class="home-button" href="index.html">Home</a>
      <div class="nav-actions">
        <a href="#summary">Comparison Table</a>
        <a href="2025_Data_Format_Report.html">2025 Data Format Report</a>
      </div>
    </nav>
  </header>

  <main class="container page">
    <section class="card hero-card">
      <div class="hero-card__heading">
        <h1>Big Data Formats Explorer</h1>
        <span class="pill">CSV · JSON · XML · Parquet · ORC · Arrow · Avro · Protobuf · Thrift · SequenceFile · TFRecord · HDF5 · NetCDF · Delta · Iceberg · Hudi · Kudu</span>
      </div>
      <p class="lead">Identify the right file, table, and serialization formats for ingestion, analytics, streaming, and lakehouse workloads.</p>
      <p>Scan the curated library to understand lifecycle fit, compare strengths in the sortable summary table, and open each card for implementation notes and examples.</p>
    </section>

    <section class="section">
      <h2>Foundational Concepts</h2>
      <div class="card concept-card">
        <h3>Row vs. Columnar Storage</h3>
        <p><strong>Row-oriented</strong> formats (like CSV) store data record-by-record. This is efficient for reading entire rows but inefficient for analytical queries that only need a few columns. <strong>Columnar-oriented</strong> formats (like Parquet and ORC) store data grouped by column. This is a game-changer for analytics because you can read only the columns you need, drastically reducing I/O and enabling better compression.
        
        </p>
      </div>
      <div class="card concept-card">
        <h3>Schema-on-Read vs. Schema-on-Write</h3>
        <p>With <strong>Schema-on-Write</strong> (e.g., Parquet), the data must conform to a strict, pre-defined schema before being written. This guarantees data quality upfront. With <strong>Schema-on-Read</strong> (e.g., JSON), the schema is applied during the read operation, offering flexibility but potentially leading to data quality issues if the data is inconsistent.</p>
      </div>
      <div class="card concept-card">
        <h3>Lakehouse Formats Explained</h3>
        <p>Lakehouse formats like Delta Lake, Iceberg, and Hudi are built on top of other storage formats (often Parquet). They add critical features of data warehouses to a data lake, such as **ACID transactions** (enabling reliable updates and deletes), **time travel** (for querying historical data), and robust **schema evolution** to handle changing data structures.</p>
      </div>
    </section>

    <section class="section">
      <h2>Lifecycle Flow</h2>
      <div class="flow-diagram-container">
        <div class="flow-step">Ingestion<br><small>CSV, JSON, Logs</small></div>
        <div class="flow-arrow">&#8594;</div>
        <div class="flow-step">Serialization<br><small>Avro, Protobuf</small></div>
        <div class="flow-arrow">&#8594;</div>
        <div class="flow-step">Storage<br><small>Parquet, ORC</small></div>
        <div class="flow-arrow">&#8594;</div>
        <div class="flow-step">Table Layer<br><small>Delta, Iceberg, Hudi</small></div>
      </div>
    </section>

    <section class="card filters-panel">
      <div class="filters-panel__header">
        <h2>Explore the library</h2>
        <p>Search across formats or focus on a lifecycle stage to surface the structures that match your pipeline.</p>
      </div>
      <div class="toolbar">
        <input id="search" type="search" placeholder="Search formats, tech, scenarios…" />
        <select id="category">
          <option value="">All Categories</option>
          <option>Text/Simple</option>
          <option>Columnar</option>
          <option>Row/Serialization</option>
          <option>Binary/Scientific</option>
          <option>Lakehouse/Table</option>
        </select>
        <select id="lifecycle">
          <option value="">All Lifecycle Stages</option>
          <option>Ingestion</option>
          <option>Serialization/Streaming</option>
          <option>Storage</option>
          <option>Table/Transaction Layer</option>
          <option>Analytics/ML</option>
        </select>
        <button data-filter-type="use-case" data-filter-value="Streaming">Streaming</button>
        <button data-filter-type="use-case" data-filter-value="Analytics">Analytics</button>
        <button data-filter-type="use-case" data-filter-value="Lakehouse">Lakehouse</button>
        <span class="small">Tip: Press <span class="kbd">/</span> to focus search</span>
      </div>
    </section>

    <section class="section">
      <h2>Summary Comparison (Sortable)</h2>
      <div class="card">
        <table id="summary">
          <thead>
            <tr>
              <th data-key="format">Format</th>
              <th data-key="schema" title="Does it have a predefined schema?">Schema</th>
              <th data-key="compression" title="Is it optimized for compression?">Compression</th>
              <th data-key="analytics" title="Is it good for analytical queries?">Analytics</th>
              <th data-key="streaming" title="Is it good for streaming data?">Streaming</th>
              <th data-key="category" title="What kind of format is it?">Category</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <p class="small">Click a column header to sort.</p>
      </div>
    </section>

    <section class="section">
      <h2>Formats Reference</h2>
      <div class="card format-browser">
        <div id="formatTabs" class="format-tabs" role="tablist" aria-label="Data formats"></div>
        <div id="formatPanel" class="format-panel" role="tabpanel" tabindex="0"></div>
      </div>
    </section>

    <footer>© Big Data Formats Interactive. Built with vanilla HTML/CSS/JS for portability.</footer>
  </main>

<script>
const formats = [
  // Text/Simple
  {
    name: "CSV", category: "Text/Simple", lifecycle: ["Ingestion","Storage"],
    description: "Simple text-based format for tabular data. Human-readable, no fixed schema, inefficient at scale.",
    exampleLang: "csv",
    example: "id,name,age,salary\n101,John,30,50000\n102,Alice,28,60000",
    scenarios: ["Data exchange between heterogeneous systems", "Initial ingestion into Hadoop/Spark", "Small datasets"],
    technologies: ["Excel","pandas","Hive","Spark","Hadoop MapReduce"],
    summary: { schema:"No", compression:"No", analytics:"Low", streaming:"No" }
  },
  { name:"JSON", category:"Text/Simple", lifecycle:["Ingestion","Analytics/ML"],
    description:"Text-based semi-structured format, self-describing and flexible. Supports nested objects/arrays.",
    exampleLang:"json",
    example:'{\n  "id": 101,\n  "name": "John",\n  "skills": ["Java","Python"]\n}',
    scenarios:["APIs and log data","Semi-structured storage","Web apps/NoSQL"],
    technologies:["MongoDB","Elasticsearch","Spark","Kafka","REST APIs"],
    summary:{ schema:"Yes (self-describing)", compression:"No", analytics:"Low–Medium", streaming:"Yes" }
  },
  { name:"XML", category:"Text/Simple", lifecycle:["Ingestion"],
    description:"Text-based hierarchical format, tag-driven, verbose; common in legacy enterprise integrations.",
    exampleLang:"xml",
    example:"<employee>\n  <id>101</id>\n  <name>John</name>\n  <age>30</age>\n</employee>",
    scenarios:["Enterprise data exchange","Configuration files","Legacy integration"],
    technologies:["SOAP","Enterprise middleware","Hadoop ingestion"],
    summary:{ schema:"Yes", compression:"No", analytics:"Low", streaming:"No" }
  },

  // Columnar
  { name:"Parquet", category:"Columnar", lifecycle:["Storage","Analytics/ML"],
    description:"Columnar storage with efficient compression/encoding; optimized for analytical queries and nested data.",
    exampleLang:"python",
    example:"df.write.parquet('employee.parquet')\ndf2 = spark.read.parquet('employee.parquet')",
    scenarios:["Analytical queries with columnar access","Large datasets & storage efficiency","Cloud OLAP"],
    technologies:["Spark","Hive","Presto","Impala","AWS Athena","BigQuery"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"Limited" }
  },
  { name:"ORC", category:"Columnar", lifecycle:["Storage","Analytics/ML"],
    description:"Columnar format from the Hadoop ecosystem; stores data in stripes; excellent compression & read speed.",
    exampleLang:"sql",
    example:"CREATE TABLE employees_orc (id INT, name STRING, salary FLOAT)\nSTORED AS ORC;",
    scenarios:["Hive workloads","ETL pipelines","Large-scale Hadoop analytics"],
    technologies:["Hive","Spark","Hadoop ecosystem"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"Limited" }
  },
  { name:"Arrow/Feather", category:"Columnar", lifecycle:["Analytics/ML"],
    description:"Apache Arrow is an in-memory columnar format for fast cross-language analytics; Feather is its file format.",
    exampleLang:"python",
    example:"import pyarrow.feather as feather\nfeather.write_feather(df, 'employee.feather')",
    scenarios:["In-memory analytics (pandas/R)","Sharing data across languages","ML/AI pipelines"],
    technologies:["Pandas","R","Apache Arrow"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"No" }
  },

  // Row/Serialization
  { name:"Avro", category:"Row/Serialization", lifecycle:["Serialization/Streaming","Storage"],
    description:"Row-based binary with schema stored alongside data. Fast serialization and schema evolution.",
    exampleLang:"json",
    example:'{ "type": "record", "name": "Employee", "fields": [{"name":"id","type":"int"},{"name":"name","type":"string"}] }',
    scenarios:["Kafka event streaming","Cross-system serialization","Schema evolution"],
    technologies:["Kafka","Hadoop","Hive","Spark","NiFi"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"Medium", streaming:"Yes" }
  },
  { name:"Protobuf", category:"Row/Serialization", lifecycle:["Serialization/Streaming"],
    description:"Language-neutral, platform-neutral binary serialization (Google). Schema-first; compact and fast.",
    exampleLang:"proto",
    example:"message Employee {\n  int32 id = 1;\n  string name = 2;\n}",
    scenarios:["Microservices communication","Event streaming","High-performance APIs"],
    technologies:["gRPC","Kafka","ML pipelines"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"Medium", streaming:"Yes" }
  },
  { name:"Thrift", category:"Row/Serialization", lifecycle:["Serialization/Streaming"],
    description:"Cross-language serialization and RPC framework (Apache).",
    exampleLang:"thrift",
    example:"struct Employee {\n  1: i32 id,\n  2: string name\n}",
    scenarios:["Cross-language data exchange","RPC in distributed systems"],
    technologies:["Cassandra","Hadoop RPC"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"Medium", streaming:"Yes" }
  },

  // Binary/Scientific
  { name:"SequenceFile", category:"Binary/Scientific", lifecycle:["Storage"],
    description:"Binary key–value file format native to Hadoop MapReduce (intermediate storage).",
    exampleLang:"text",
    example:"Key: row1\nValue: <record bytes>",
    scenarios:["Intermediate MapReduce storage","Binary KV datasets"],
    technologies:["Hadoop","Hive"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"Medium", streaming:"No" }
  },
  { name:"TFRecord", category:"Binary/Scientific", lifecycle:["Analytics/ML"],
    description:"Binary format for TensorFlow pipelines; stores serialized Example/SequenceExample protocol buffers.",
    exampleLang:"python",
    example:"import tensorflow as tf\nexample = tf.train.Example(...)",
    scenarios:["Training ML models","Image/audio/video pipelines"],
    technologies:["TensorFlow","TF Data"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"Medium", streaming:"Yes" }
  },
  { name:"HDF5", category:"Binary/Scientific", lifecycle:["Storage","Analytics/ML"],
    description:"Binary hierarchical format for scientific computing; supports large multidimensional arrays.",
    exampleLang:"text",
    example:"/group/dataset  (hierarchical)",
    scenarios:["Scientific simulations","Large array storage","Engineering datasets"],
    technologies:["h5py","MATLAB","R"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"No" }
  },
  { name:"NetCDF", category:"Binary/Scientific", lifecycle:["Storage","Analytics/ML"],
    description:"Binary format for multidimensional scientific data; widely used in climate and meteorology.",
    exampleLang:"text",
    example:"Dimensions: time, latitude, longitude",
    scenarios:["Climate modeling","Meteorology","Geoscience"],
    technologies:["netCDF libraries","Climate toolchains"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"No" }
  },

  // Lakehouse/Table
  { name:"Delta Lake", category:"Lakehouse/Table", lifecycle:["Table/Transaction Layer","Storage"],
    description:"Open-source storage layer (on Parquet) adding ACID transactions, schema evolution, time travel.",
    exampleLang:"python",
    example:"df.write.format('delta').save('/delta/employees')",
    scenarios:["Slowly changing dimensions","Batch+streaming ingestion","Schema evolution"],
    technologies:["Databricks","Spark","Azure Synapse"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"Yes" }
  },
  { name:"Iceberg", category:"Lakehouse/Table", lifecycle:["Table/Transaction Layer","Storage"],
    description:"Open table format for huge analytic datasets; partition evolution, schema evolution, time travel.",
    exampleLang:"sql",
    example:"CREATE TABLE db.employees (id INT, name STRING) USING iceberg;",
    scenarios:["Analytics on data lakes","Time travel queries","Lakehouse architectures"],
    technologies:["Spark","Trino","Flink","Presto"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"Yes" }
  },
  { name:"Hudi", category:"Lakehouse/Table", lifecycle:["Table/Transaction Layer","Storage"],
    description:"Table format enabling upserts/deletes and incremental processing on data lakes.",
    exampleLang:"text",
    example:"Hoodie table with incremental updates",
    scenarios:["CDC (Change Data Capture)","Real-time ingestion","ETL workflows"],
    technologies:["Spark","Hive","Presto","Flink"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"Yes" }
  },
  { name:"Kudu", category:"Lakehouse/Table", lifecycle:["Table/Transaction Layer","Storage"],
    description:"Columnar store supporting fast analytics with OLTP-like updates (tablet-based).",
    exampleLang:"text",
    example:"Data sharded into tablets across nodes",
    scenarios:["Fast analytics on fresh data","Near real-time reporting"],
    technologies:["Impala","Spark","Hadoop ecosystem"],
    summary:{ schema:"Yes", compression:"Yes", analytics:"High", streaming:"Yes" }
  }
];

// Get references to all the HTML elements we need to interact with
const summaryBody = document.querySelector('#summary tbody');
const tabsContainer = document.getElementById('formatTabs');
const formatPanel = document.getElementById('formatPanel');
const searchInput = document.getElementById('search');
const categorySelect = document.getElementById('category');
const lifecycleSelect = document.getElementById('lifecycle');
const quickFilterButtons = document.querySelectorAll('[data-filter-type="use-case"]');

// Store the full list of formats for filtering and sorting
let currentFormats = [...formats];
let activeFormatSlug = '';

// ====================================================================
// Functions for Rendering & Displaying
// ====================================================================

const slugify = (name) => name.replace(/\s+/g, '-').toLowerCase();

// Renders the summary table rows based on a given list of formats
function renderSummary(data) {
  summaryBody.innerHTML = data.map(r => {
    const slug = slugify(r.name);
    return `
    <tr data-format-name="${slug}">
      <td>${r.name}</td>
      <td>${r.summary.schema}</td>
      <td>${r.summary.compression}</td>
      <td>${r.summary.analytics}</td>
      <td>${r.summary.streaming}</td>
      <td>${r.category}</td>
    </tr>
  `;
  }).join("");
}

// Generates the code block for each format card
function snippetBlock(fmt) {
  const id = 'code_' + btoa(fmt.name).replace(/=/g,"");
  return `
    <button class="copy-btn" data-target="${id}">Copy</button>
    <pre id="${id}"><code class="language-${fmt.exampleLang}">${fmt.example.replace(/</g,"&lt;")}</code></pre>
  `;
}

// Generates a list of tags for a given array of strings
function tagList(items, cls="tag") {
  return items.map(t => `<span class="${cls}">${t}</span>`).join(" ");
}

function formatCardTemplate(fmt) {
  const slug = slugify(fmt.name);
  return `
    <div class="format-card" data-format-slug="${slug}">
      <div class="row">
        <h3 style="margin-right:8px">${fmt.name}</h3>
        <span class="pill">${fmt.category}</span>
        ${fmt.lifecycle.map(s=>`<span class="tag">${s}</span>`).join("")}
      </div>
      <p>${fmt.description}</p>
      <div class="format-card__section">
        <h4>Example</h4>
        ${snippetBlock(fmt)}
      </div>
      <div class="format-card__section">
        <h4>Scenarios</h4>
        <div>${tagList(fmt.scenarios)}</div>
      </div>
      <div class="format-card__section">
        <h4>Technologies</h4>
        <div>${tagList(fmt.technologies)}</div>
      </div>
    </div>
  `;
}

function renderFormatBrowser(list) {
  if (!list.length) {
    tabsContainer.innerHTML = '';
    formatPanel.innerHTML = '<p class="format-empty">No formats match your filters. Adjust the search or lifecycle selections.</p>';
    formatPanel.removeAttribute('data-format-slug');
    formatPanel.removeAttribute('aria-labelledby');
    activeFormatSlug = '';
    return;
  }

  if (!activeFormatSlug || !list.some(f => slugify(f.name) === activeFormatSlug)) {
    activeFormatSlug = slugify(list[0].name);
  }

  tabsContainer.innerHTML = list.map(f => {
    const slug = slugify(f.name);
    const isActive = slug === activeFormatSlug;
    return `<button class="format-tab ${isActive ? 'active' : ''}" role="tab" aria-selected="${isActive ? 'true' : 'false'}" aria-controls="formatPanel" id="tab-${slug}" data-format-slug="${slug}">${f.name}</button>`;
  }).join('');

  const activeFormat = list.find(f => slugify(f.name) === activeFormatSlug);

  if (activeFormat) {
    formatPanel.innerHTML = formatCardTemplate(activeFormat);
    formatPanel.setAttribute('data-format-slug', activeFormatSlug);
    formatPanel.setAttribute('aria-labelledby', `tab-${activeFormatSlug}`);
  } else {
    formatPanel.innerHTML = '';
    formatPanel.removeAttribute('data-format-slug');
    formatPanel.removeAttribute('aria-labelledby');
  }

  tabsContainer.querySelectorAll('.format-tab').forEach(btn => {
    btn.addEventListener('click', () => {
      const slug = btn.getAttribute('data-format-slug');
      if (slug === activeFormatSlug) return;
      activeFormatSlug = slug;
      renderFormatBrowser(list);
      if (typeof formatPanel.focus === 'function') {
        formatPanel.focus();
      }
    });
  });
}

// Initial render of both tables and cards
renderSummary(formats);
renderFormatBrowser(formats);

// ====================================================================
// Interactivity: Sorting, Filtering, and Highlighting
// ====================================================================

// Initial sort state for the summary table
let sortState = { key: 'format', dir: 1 };
document.querySelectorAll('#summary th').forEach(th => {
  th.addEventListener('click', () => {
    const key = th.dataset.key;
    // Reverse sort direction if the same column is clicked
    sortState.dir = (sortState.key === key) ? -sortState.dir : 1;
    sortState.key = key;

    // Sort the current filtered list of formats
    currentFormats.sort((a, b) => {
      let aVal, bVal;
      switch(key) {
        case 'format': aVal = a.name; bVal = b.name; break;
        case 'schema': aVal = a.summary.schema; bVal = b.summary.schema; break;
        case 'compression': aVal = a.summary.compression; bVal = b.summary.compression; break;
        case 'analytics': aVal = a.summary.analytics; bVal = b.summary.analytics; break;
        case 'streaming': aVal = a.summary.streaming; bVal = b.summary.streaming; break;
        case 'category': aVal = a.category; bVal = b.category; break;
      }
      return aVal.localeCompare(bVal) * sortState.dir;
    });

    renderSummary(currentFormats);
  });
});

// Function to apply all filters and re-render the content
function applyFilters() {
  const query = searchInput.value.toLowerCase();
  const category = categorySelect.value;
  const lifecycle = lifecycleSelect.value;
  
  // Filter the original `formats` array to get the new list
  currentFormats = formats.filter(f => {
    const text = (f.name + " " + f.category + " " + f.description + " " + f.scenarios.join(" ") + " " + f.technologies.join(" ")).toLowerCase();
    const matchQ = !query || text.includes(query);
    const matchC = !category || f.category === category;
    const matchL = !lifecycle || f.lifecycle.includes(lifecycle);
    return matchQ && matchC && matchL;
  });

  renderSummary(currentFormats);
  renderFormatBrowser(currentFormats);
}

// Add event listeners for all filter elements
[searchInput, categorySelect, lifecycleSelect].forEach(el => el.addEventListener('input', applyFilters));

// Add event listeners for quick filter buttons
quickFilterButtons.forEach(button => {
  button.addEventListener('click', () => {
    const filterValue = button.getAttribute('data-filter-value');
    
    // Set the filter values based on the button clicked
    switch(filterValue) {
      case 'Streaming':
        categorySelect.value = '';
        lifecycleSelect.value = 'Serialization/Streaming';
        break;
      case 'Analytics':
        categorySelect.value = 'Columnar';
        lifecycleSelect.value = 'Analytics/ML';
        break;
      case 'Lakehouse':
        categorySelect.value = 'Lakehouse/Table';
        lifecycleSelect.value = 'Table/Transaction Layer';
        break;
      default:
        categorySelect.value = '';
        lifecycleSelect.value = '';
    }
    // Trigger the filtering process
    applyFilters();
  });
});


// Add keyboard shortcut to focus the search bar
window.addEventListener('keydown', (e) => {
  if (e.key === '/' && document.activeElement !== searchInput) {
    e.preventDefault();
    searchInput.focus();
  }
});

// Add a highlight on hover for the summary table rows and corresponding cards
function togglePanelHighlight(slug, state) {
  if (!slug) return;
  const panelSlug = formatPanel.getAttribute('data-format-slug');
  if (panelSlug !== slug) return;
  const activeCard = formatPanel.querySelector('.format-card');
  if (activeCard) {
    activeCard.classList.toggle('highlight', state);
  }
}

summaryBody.addEventListener('mouseover', (e) => {
  const row = e.target.closest('tr');
  if (row) {
    const slug = row.getAttribute('data-format-name');
    togglePanelHighlight(slug, true);
  }
});

summaryBody.addEventListener('mouseout', (e) => {
  const row = e.target.closest('tr');
  if (row) {
    const slug = row.getAttribute('data-format-name');
    togglePanelHighlight(slug, false);
  } else {
    togglePanelHighlight(formatPanel.getAttribute('data-format-slug'), false);
  }
});

// ====================================================================
// Copy-to-clipboard functionality
// ====================================================================

document.addEventListener('click', (e) => {
  if (e.target.classList.contains('copy-btn')) {
    const id = e.target.getAttribute('data-target');
    const el = document.getElementById(id);
    const text = el.innerText;
    navigator.clipboard.writeText(text).then(() => {
      e.target.textContent = "Copied!";
      setTimeout(()=> e.target.textContent = "Copy", 1000);
    });
  }
});

</script>
</body>
</html>

