<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MapReduce Visual Simulator — Regional Sales (6 Data Nodes)</title>
  <style>
    :root{
      --bg:#0b1220;      /* deep slate */
      --panel:#131c2b;   /* card base */
      --muted:#8aa0bf;   /* muted text */
      --text:#e6edf7;    /* primary text */
      --accent:#67e8f9;  /* cyan */
      --accent2:#a78bfa; /* violet */
      --good:#86efac;    /* green */
      --warn:#facc15;    /* yellow */
      --bad:#fda4af;     /* rose */
      --grid:#1b2537;
      --chip:#1a2335;
      --shadow: 0 8px 28px rgba(0,0,0,0.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% -10%, #12203a 0%, transparent 60%),
                  radial-gradient(1000px 600px at 90% 0%, #121a2a 0%, transparent 60%),
                  var(--bg);
      color:var(--text);
    }
    .app{max-width:1200px; margin:24px auto; padding:0 16px 56px}
    header{
      display:flex; align-items:center; justify-content:space-between; gap:16px;
      margin-bottom:16px;
    }
    .title{font-size:clamp(22px, 2.6vw, 34px); font-weight:800; letter-spacing:0.3px}
    .subtitle{color:var(--muted); font-size:14px}

    .controls{
      background:linear-gradient(180deg, #14223a 0%, #0f1828 100%);
      border:1px solid #1e2a44; border-radius:16px; padding:14px; box-shadow:var(--shadow);
      display:grid; grid-template-columns: repeat(12, 1fr); gap:12px; align-items:end; position:sticky; top:8px; z-index:10;
    }
    .control{display:flex; flex-direction:column; gap:6px}
    .control label{font-size:12px; color:var(--muted)}
    input[type="number"], input[type="text"], select{
      background:#0e1727; border:1px solid #24314d; color:var(--text);
      padding:10px 12px; border-radius:10px; outline:none; width:100%;
    }
    .btn{background:linear-gradient(180deg,#1a2a45,#142037); border:1px solid #283a5f; color:var(--text);
      padding:10px 14px; border-radius:12px; cursor:pointer; font-weight:700; letter-spacing:.2px}
    .btn:hover{filter:brightness(1.08)}
    .btn:active{transform:translateY(1px)}
    .btn.secondary{background:#0e1727}

    .phase{
      margin:16px 0 8px; display:flex; align-items:center; justify-content:space-between; gap:12px
    }
    .phase-name{font-weight:800; font-size:18px}
    .phase-desc{color:var(--muted); font-size:14px}

    .stage{position:relative; margin-top:10px}

    .grid{display:grid; gap:12px}
    .nodes{grid-template-columns:repeat(3,1fr)}
    .reducers{grid-template-columns:repeat(3,1fr)}

    .card{
      background:linear-gradient(180deg, #111a2c, #0d1626);
      border:1px solid #1d2741; border-radius:14px; padding:12px; box-shadow:var(--shadow);
      position:relative; overflow:hidden;
    }
    .card h3{margin:0 0 8px; font-size:14px; letter-spacing:.3px}
    .meta{color:var(--muted); font-size:12px; margin-bottom:8px}
    .data{background: #0b1424; border:1px solid #1b2741; border-radius:10px; padding:8px;}
    table{width:100%; border-collapse:collapse; font-size:12px}
    th,td{border-bottom:1px dashed #233356; padding:6px 6px; text-align:left}
    th{color:#a3b9d8; font-weight:700}
    tr:last-child td{border-bottom:none}

    .kv{display:flex; flex-wrap:wrap; gap:6px}
    .chip{
      background:var(--chip); border:1px solid #293756; border-radius:999px; padding:6px 10px; font-size:12px; white-space:nowrap
    }
    .chip.k{border-color:#2b4368}
    .chip.v{border-color:#3e2b68}

    .legend{display:flex; flex-wrap:wrap; gap:8px; margin-top:10px}
    .legend .chip{opacity:.9}

    #wires{position:absolute; inset:0; pointer-events:none}
    .answer{margin-top:16px; background:linear-gradient(180deg, #0f1a2c, #0b1322); border:1px solid #203055; border-radius:14px; padding:14px}
    .answer h3{margin:0 0 8px}

    .hint{font-size:12px; color:var(--muted)}

    @media (max-width: 900px){
      .nodes{grid-template-columns:repeat(2,1fr)}
      .reducers{grid-template-columns:repeat(2,1fr)}
    }
    @media (max-width: 640px){
      .controls{grid-template-columns:1fr; position:static}
      .nodes{grid-template-columns:1fr}
      .reducers{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div>
        <div class="title">MapReduce Visual Simulator</div>
        <div class="subtitle">Dataset: Monthly Regional Sales • 6 Data Nodes • Visualize each phase → Input ➝ Map ➝ Combine ➝ Shuffle/Sort ➝ Reduce ➝ Top‑3</div>
      </div>
    </header>

    <section class="controls">
      <div class="control" style="grid-column: span 2; min-width:140px">
        <label for="seed">Random Seed</label>
        <input id="seed" type="number" value="42" />
      </div>
      <div class="control" style="grid-column: span 3; min-width:180px">
        <label for="rpn">Records per Node</label>
        <input id="rpn" type="number" value="10" min="5" max="50" />
      </div>
      <div class="control" style="grid-column: span 3; min-width:180px">
        <label for="reducersN">Reducers</label>
        <select id="reducersN">
          <option value="3" selected>3</option>
          <option value="2">2</option>
          <option value="4">4</option>
        </select>
      </div>
      <div class="control" style="grid-column: span 4; min-width:240px">
        <label>&nbsp;</label>
        <div style="display:flex; gap:8px; flex-wrap:wrap">
          <button class="btn" id="btnRegenerate">Regenerate Dataset</button>
          <button class="btn secondary" id="btnReset">Reset</button>
          <button class="btn" id="btnPrev">◀︎ Prev</button>
          <button class="btn" id="btnNext">Next ▶︎</button>
          <button class="btn" id="btnPlay">► Play</button>
        </div>
      </div>
      <div class="control" style="grid-column: 1 / -1">
        <div class="hint">Tip: Use <b>Next</b> to step through the phases. <b>Play</b> will auto‑advance. You can change seed / records / reducers and click <b>Regenerate Dataset</b> anytime.</div>
      </div>
    </section>

    <div class="phase">
      <div class="phase-name" id="phaseName"></div>
      <div class="phase-desc" id="phaseDesc"></div>
    </div>

    <section class="stage">
      <svg id="wires" viewBox="0 0 1200 800" preserveAspectRatio="none">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#4cc9f0"/>
          </marker>
        </defs>
      </svg>
      <div class="grid nodes" id="nodes"></div>
      <div class="grid reducers" id="reducers" style="margin-top:12px"></div>
      <div id="final"></div>
      <div class="legend" id="legend"></div>
    </section>
  </div>

  <script>
  (function(){
    // ===== Util: deterministic PRNG (Mulberry32) =====
    function mulberry32(a){
      return function(){
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }
    function pickWeighted(rng, items){
      // items: [{v, w}]
      const total = items.reduce((s, it)=>s+it.w, 0);
      const x = rng()*total; let acc=0;
      for(const it of items){acc+=it.w; if(x<=acc) return it.v;}
      return items[items.length-1].v;
    }
    function currency(n){return n.toLocaleString(undefined,{maximumFractionDigits:0});}
    function sum(arr){return arr.reduce((a,b)=>a+b,0)}
    function hashStr(s){let h=0; for(let i=0;i<s.length;i++){h = (h*31 + s.charCodeAt(i))|0;} return Math.abs(h);}    

    // ===== DOM refs =====
    const elSeed = document.getElementById('seed');
    const elRpn = document.getElementById('rpn');
    const elReducersN = document.getElementById('reducersN');
    const elNodes = document.getElementById('nodes');
    const elReducers = document.getElementById('reducers');
    const elWires = document.getElementById('wires');
    const elFinal = document.getElementById('final');
    const elPhaseName = document.getElementById('phaseName');
    const elPhaseDesc = document.getElementById('phaseDesc');
    const elLegend = document.getElementById('legend');

    const btnRegenerate = document.getElementById('btnRegenerate');
    const btnReset = document.getElementById('btnReset');
    const btnPrev = document.getElementById('btnPrev');
    const btnNext = document.getElementById('btnNext');
    const btnPlay = document.getElementById('btnPlay');

    // ===== Global Sim State =====
    const REGIONS = [
      'North','South','East','West','Central','Northeast','Northwest','Southwest'
    ];
    const REGION_WEIGHTS = {
      'North':1.08,'South':1.25,'East':1.0,'West':1.18,
      'Central':0.92,'Northeast':0.82,'Northwest':0.78,'Southwest':0.7
    };
    const COLORS = {
      'North':'#60a5fa','South':'#34d399','East':'#f472b6','West':'#f59e0b',
      'Central':'#a78bfa','Northeast':'#f87171','Northwest':'#22d3ee','Southwest':'#c084fc'
    };

    const PHASES = [
      {name:'Phase 0 — Input & Splits', desc:'Data is loaded from 6 data nodes. Each input split is processed by a mapper.'},
      {name:'Phase 1 — Map', desc:'Mappers transform each record into key–value pairs: (region, saleAmount).'},
      {name:'Phase 2 — Optional Combine', desc:'Local combiners (at each node) partially sum amounts per region to reduce shuffle volume.'},
      {name:'Phase 3 — Shuffle & Sort', desc:'Key groups are partitioned by a hash and routed to reducers. Each reducer receives all values for a given key.'},
      {name:'Phase 4 — Reduce', desc:'Reducers aggregate values per region to compute monthly totals.'},
      {name:'Phase 5 — Final Answer', desc:'Totals are sorted to find the Top‑3 sales regions for this month.'},
    ];

    let state = {
      phase:0,
      nodes:[],              // [{id, records:[{id,region,amount}]}]
      mapped:[],             // per node: [{k, v}]
      combined:[],           // per node: {region:partialSum}
      shuffle:null,          // {reducers:[{buckets:{region:[values]}}]}
      reduce:null,           // {reducers:[{out:{region:sum}}], totals:{region:sum}}
      top3:[]
    };

    function generateDataset(){
      const seed = parseInt(elSeed.value)||42;
      const rpn = Math.max(1, parseInt(elRpn.value)||10);
      const rng = mulberry32(seed);
      const regionPool = REGIONS.map(r=>({v:r, w:REGION_WEIGHTS[r]}));

      const nodes = Array.from({length:6}, (_,i)=>({id:`DN${i+1}`, records:[]}));
      let serial = 1;
      for(const node of nodes){
        for(let i=0;i<rpn;i++){
          const region = pickWeighted(rng, regionPool);
          const amount = Math.floor( (rng()*900) + 100 ); // 100..999
          node.records.push({ id:`S${serial++}`, region, amount });
        }
      }
      state.nodes = nodes;
      state.mapped = [];
      state.combined = [];
      state.shuffle = null;
      state.reduce = null;
      state.top3 = [];
      state.phase = 0;
      render();
    }

    // ====== Map phase ======
    function doMap(){
      state.mapped = state.nodes.map(node => node.records.map(r=>({k:r.region, v:r.amount, id:r.id})));
    }

    // ====== Combine phase ======
    function doCombine(){
      state.combined = state.mapped.map(pairs => {
        const acc = {};
        for(const {k,v} of pairs){ acc[k] = (acc[k]||0) + v; }
        return acc; // {region: partialSum}
      });
    }

    // ====== Shuffle & Sort ======
    function doShuffle(){
      const reducersN = parseInt(elReducersN.value)||3;
      const reducers = Array.from({length:reducersN}, ()=>({buckets:{}}));

      // Use combined output if available, else raw mapped pairs
      const useCombined = state.combined && state.combined.length === state.nodes.length;
      if(useCombined){
        state.combined.forEach((part, nodeIdx)=>{
          for(const [region,val] of Object.entries(part)){
            const ridx = hashStr(region) % reducersN;
            const buckets = reducers[ridx].buckets;
            (buckets[region] ||= []).push(val);
          }
        });
      } else {
        state.mapped.forEach((pairs, nodeIdx)=>{
          for(const {k:vKey, v:val} of pairs){
            const ridx = hashStr(vKey) % reducersN;
            const buckets = reducers[ridx].buckets;
            (buckets[vKey] ||= []).push(val);
          }
        });
      }

      // Sort values per key (not required but for display determinism)
      for(const r of reducers){
        for(const k of Object.keys(r.buckets).sort()){
          r.buckets[k] = r.buckets[k].slice().sort((a,b)=>a-b);
        }
      }
      state.shuffle = {reducers};
    }

    // ====== Reduce phase ======
    function doReduce(){
      if(!state.shuffle) return;
      const outReducers = state.shuffle.reducers.map(r=>{
        const out = {};
        for(const [k,vals] of Object.entries(r.buckets)){
          out[k] = sum(vals);
        }
        return {out};
      });
      const totals = {};
      for(const r of outReducers){
        for(const [k,v] of Object.entries(r.out)){
          totals[k] = (totals[k]||0) + v;
        }
      }
      state.reduce = {reducers: outReducers, totals};
    }

    function doFinal(){
      if(!state.reduce) return;
      const entries = Object.entries(state.reduce.totals);
      entries.sort((a,b)=>b[1]-a[1]);
      state.top3 = entries.slice(0,3);
    }

    // ===== Rendering =====
    function render(){
      // Phase label
      const P = PHASES[state.phase];
      elPhaseName.textContent = P.name;
      elPhaseDesc.textContent = P.desc;

      // Clear stage
      elNodes.innerHTML = '';
      elReducers.innerHTML = '';
      elLegend.innerHTML = '';
      elFinal.innerHTML = '';
      clearWires();

      // Legend
      const legendTitle = document.createElement('div');
      legendTitle.className = 'chip'; legendTitle.textContent = 'Regions';
      elLegend.appendChild(legendTitle);
      for(const r of REGIONS){
        const c = document.createElement('div'); c.className = 'chip'; c.style.borderColor = COLORS[r]; c.textContent = r; elLegend.appendChild(c);
      }

      // Nodes grid always rendered in all phases <= 2,3
      if(state.phase === 0){ renderPhase0(); }
      else if(state.phase === 1){ doMap(); renderPhase1(); }
      else if(state.phase === 2){ if(!state.mapped.length) doMap(); doCombine(); renderPhase2(); }
      else if(state.phase === 3){ if(!state.mapped.length) doMap(); if(!state.combined.length) doCombine(); doShuffle(); renderPhase3(); }
      else if(state.phase === 4){ if(!state.shuffle) { if(!state.mapped.length) doMap(); if(!state.combined.length) doCombine(); doShuffle(); } doReduce(); renderPhase4(); }
      else if(state.phase === 5){ if(!state.reduce){ if(!state.shuffle){ if(!state.mapped.length) doMap(); if(!state.combined.length) doCombine(); doShuffle(); } doReduce(); } doFinal(); renderPhase5(); }

      // controls enabling
      btnPrev.disabled = state.phase===0;
      btnNext.disabled = state.phase===5;
    }

    function card(title, subtitleHTML, innerHTML, id){
      const div = document.createElement('div');
      div.className = 'card';
      if(id) div.id = id;
      const h = document.createElement('h3'); h.textContent = title; div.appendChild(h);
      if(subtitleHTML){ const m=document.createElement('div'); m.className='meta'; m.innerHTML=subtitleHTML; div.appendChild(m);}    
      const box = document.createElement('div'); box.className='data'; box.innerHTML = innerHTML; div.appendChild(box);
      return div;
    }

    function table(headers, rows){
      const th = headers.map(h=>`<th>${h}</th>`).join('');
      const tr = rows.map(r=>`<tr>${r.map(c=>`<td>${c}</td>`).join('')}</tr>`).join('');
      return `<table><thead><tr>${th}</tr></thead><tbody>${tr}</tbody></table>`;
    }

    // === Phase 0: Input ===
    function renderPhase0(){
      state.nodes.forEach((node, i)=>{
        const rows = node.records.map(r=>[
          r.id, `<span class="chip" style="border-color:${COLORS[r.region]}">${r.region}</span>`, currency(r.amount)
        ]);
        const total = sum(node.records.map(r=>r.amount));
        const c = card(`${node.id} • Input Split`, `Records: <b>${node.records.length}</b> &nbsp; | &nbsp; Node Total: <b>${currency(total)}</b>`, table(['ID','Region','Amount'], rows), `node-${i}`);
        elNodes.appendChild(c);
      });
    }

    // === Phase 1: Map ===
    function renderPhase1(){
      state.nodes.forEach((node, i)=>{
        const kvs = state.mapped[i].map(p=>`<span class="chip k" style="border-color:${COLORS[p.k]}">(${p.k}, <span class="chip v">${p.v}</span>)</span>`).join(' ');
        const c = card(`${node.id} • Map Output`, `One key–value per record`, `<div class='kv'>${kvs}</div>`, `node-${i}`);
        elNodes.appendChild(c);
      });
    }

    // === Phase 2: Combine ===
    function renderPhase2(){
      state.nodes.forEach((node, i)=>{
        const part = state.combined[i];
        const rows = Object.keys(part).sort().map(k=>[
          `<span class="chip" style="border-color:${COLORS[k]}">${k}</span>`, currency(part[k])
        ]);
        const c = card(`${node.id} • Combiner (Local Partial Sums)`, `Reduces shuffle volume by pre‑aggregating`, table(['Region','Partial Sum'], rows), `node-${i}`);
        elNodes.appendChild(c);
      });
    }

    // === Phase 3: Shuffle & Sort ===
    function renderPhase3(){
      // left: nodes showing which reducers they send to
      const reducersN = parseInt(elReducersN.value)||3;
      const nodeToReducer = {}; // map nodeIdx -> Set(reducerIdx)

      state.combined.forEach((part, nodeIdx)=>{
        const lines = [];
        const rset = new Set();
        Object.keys(part).forEach(region=>{
          const ridx = hashStr(region)%reducersN; rset.add(ridx);
          const chip = `<span class="chip" style="border-color:${COLORS[region]}">${region} ⇢ R${ridx+1}</span>`;
          lines.push(chip);
        });
        nodeToReducer[nodeIdx] = rset;
        const c = card(`${state.nodes[nodeIdx].id} • Partition`, `Hash(region) % ${reducersN}`, `<div class='kv'>${lines.join(' ')}</div>`, `node-${nodeIdx}`);
        elNodes.appendChild(c);
      });

      // right: reducers showing buckets (sorted)
      state.shuffle.reducers.forEach((r, idx)=>{
        const keys = Object.keys(r.buckets).sort();
        const rows = keys.length? keys.map(k=>[
          `<span class="chip" style="border-color:${COLORS[k]}">${k}</span>`,
          r.buckets[k].map(v=>`<span class='chip v'>${v}</span>`).join(' ')
        ]): [["—","—"]];
        const c = card(`Reducer R${idx+1} • Buckets`, `All values for each region arrive here`, table(['Region','Values (sorted)'], rows), `reducer-${idx}`);
        elReducers.appendChild(c);
      });

      // Draw wires between node cards and reducer cards (one per pair)
      drawWires(nodeToReducer, state.shuffle.reducers.length);
    }

    // === Phase 4: Reduce ===
    function renderPhase4(){
      // Show per‑reducer outputs
      state.reduce.reducers.forEach((r, idx)=>{
        const keys = Object.keys(r.out).sort((a,b)=>r.out[b]-r.out[a]);
        const rows = keys.length? keys.map(k=>[
          `<span class="chip" style="border-color:${COLORS[k]}">${k}</span>`, currency(r.out[k])
        ]): [["—","—"]];
        const c = card(`Reducer R${idx+1} • Output`, `Sum over each key (region)`, table(['Region','Sum'], rows), `reducer-${idx}`);
        elReducers.appendChild(c);
      });

      // Global totals (merge of reducers)
      const entries = Object.entries(state.reduce.totals).sort((a,b)=>b[1]-a[1]);
      const rows = entries.map(([k,v],i)=>[
        `${i+1}. <span class="chip" style="border-color:${COLORS[k]}">${k}</span>`, currency(v)
      ]);
      const totalCard = card('Monthly Totals (All Regions)', `Aggregated across reducers`, table(['Rank • Region','Total Sales'], rows));
      elFinal.appendChild(totalCard);
    }

    // === Phase 5: Final Answer ===
    function renderPhase5(){
      renderPhase4(); // show totals context
      const [a,b,c] = state.top3;
      const html = `
        <div class="answer">
          <h3>Answer — Top‑3 Regions by Sales (this month)</h3>
          <div class="kv">
            ${state.top3.map(([k,v],i)=>`<span class='chip' style='border-color:${COLORS[k]}; background:#0e1b2f'>${i+1}) ${k}: <b>${currency(v)}</b></span>`).join(' ')}
          </div>
          <div class="hint" style="margin-top:8px">Sorted descending by total sales aggregated in the <b>Reduce</b> phase.</div>
        </div>`;
      const div = document.createElement('div'); div.innerHTML = html; elFinal.appendChild(div);
    }

    // ===== Wiring (SVG) =====
    function clearWires(){ while(elWires.firstChild) elWires.removeChild(elWires.firstChild); // leave <defs> but we removed; so re-add
      const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
      marker.setAttribute('id','arrow'); marker.setAttribute('viewBox','0 0 10 10'); marker.setAttribute('refX','10'); marker.setAttribute('refY','5'); marker.setAttribute('markerWidth','6'); marker.setAttribute('markerHeight','6'); marker.setAttribute('orient','auto-start-reverse');
      const path = document.createElementNS('http://www.w3.org/2000/svg','path'); path.setAttribute('d','M 0 0 L 10 5 L 0 10 z'); path.setAttribute('fill','#4cc9f0');
      marker.appendChild(path); defs.appendChild(marker); elWires.appendChild(defs);
    }

    function drawWires(nodeToReducer, reducersN){
      clearWires();
      const nodes = Array.from({length:6}, (_,i)=>document.getElementById(`node-${i}`));
      const reducers = Array.from({length:reducersN}, (_,i)=>document.getElementById(`reducer-${i}`));
      const stage = document.querySelector('.stage');
      const srect = stage.getBoundingClientRect();

      function center(el){
        const r = el.getBoundingClientRect();
        return {x: r.left - srect.left + r.width/2, y: r.top - srect.top + r.height/2};
      }

      for(let i=0;i<nodes.length;i++){
        const from = nodes[i]; if(!from) continue;
        const src = center(from);
        const set = nodeToReducer[i] || new Set();
        for(const ridx of set){
          const to = reducers[ridx]; if(!to) continue;
          const dst = center(to);
          // Cubic curve
          const midX = (src.x + dst.x)/2;
          const c1 = {x: midX, y: src.y};
          const c2 = {x: midX, y: dst.y};
          const path = document.createElementNS('http://www.w3.org/2000/svg','path');
          path.setAttribute('d', `M ${src.x},${src.y} C ${c1.x},${c1.y} ${c2.x},${c2.y} ${dst.x},${dst.y}`);
          path.setAttribute('fill','none');
          path.setAttribute('stroke','#4cc9f0');
          path.setAttribute('stroke-width','2');
          path.setAttribute('marker-end','url(#arrow)');
          path.setAttribute('opacity','0.85');
          elWires.appendChild(path);
        }
      }
    }

    // ===== Controls =====
    btnRegenerate.addEventListener('click', generateDataset);
    btnReset.addEventListener('click', ()=>{state.phase=0; render();});
    btnPrev.addEventListener('click', ()=>{ if(state.phase>0){ state.phase--; render(); }});
    btnNext.addEventListener('click', ()=>{ if(state.phase<PHASES.length-1){ state.phase++; render(); }});

    let playing = false; let timer = null;
    btnPlay.addEventListener('click', ()=>{
      if(!playing){
        playing = true; btnPlay.textContent = '❚❚ Pause';
        timer = setInterval(()=>{
          if(state.phase < PHASES.length-1){ state.phase++; render(); }
          else { clearInterval(timer); playing=false; btnPlay.textContent='► Play'; }
        }, 1300);
      } else {
        playing = false; btnPlay.textContent = '► Play'; if(timer) clearInterval(timer);
      }
    });

    // Init
    generateDataset();
    window.addEventListener('resize', ()=>{
      // re-draw wires if in shuffle phase
      if(state.phase===3) render();
    });
  })();
  </script>
</body>
</html>
